# Γέροντας Αλέξανδρος 321/2015029
# Τσίπος Ιωάννης 321/2015207
# Ζιώζας Γεώργιος 321/2015058

.data 	
	# Δήλωση μηνυμάτων που θα τυπωθούν στην κονσόλα
	enter: .asciiz "\n\n"
	msg0: .asciiz "Calculation of the Greatest Common Divis or of two integers using Euclid's algorithm \n"
	msg1: .asciiz "Dose ton 1o arithmo: " 
	msg2: .asciiz "Dose ton 2o arithmo: " 
	msg3: .asciiz "The Greatest Common Divisor is: "
	msg4: .asciiz "Both numbers are 0s!!! \n"

.text
	# Κυρίως πρόγραμμα 
	main:
		la $a0,msg0 # Αποθήκευση διεύθυνσης msg0 στον καταχωρητή $a0 
		li $v0,4    # Κλήση για εκτέλεση εκτύπωσης string	
		syscall     # Εκτέλεση
		
		move $t2,$0 # Μηδενίζουμε την μεταβλητή $t2 η οποία είναι ο μετρητής επαναλήψεων του βρόνχου
		j loop      # Μεταφέρουμε την εκτέλεση στη συνάρτηση loop χωρίς να αποθηκεύσουμε τον μετρητή του προγράμματος
	 
	# Βρόνχος στον οποίο ζητούνται δύο αριθμοί από τον χρήστη, εκτελούμε τον αλγόριθμο του Ευκλείδη και τυπώνουμε το αποτέλεσμα
	loop:			
		# Αύξηση του μετρητή κατά 1
		add $t2, $t2, 1         # $t2 = $t2 + 1
		
		# Ο βρόνχος τερματίζει μετά από δύο επαναλήψεις
		beq $t2,3,exit          # Aν $t2 = 3 κάνε άλμα στο exit
		
		# Καλούμε την συνάρτηση give_numbers για να εισάγει ο χρήστης τους αριθμούς
		jal give_numbers        # Μεταφέρουμε την εκτέλεση στη συνάρτηση give_numbers και αποθηκεύουμε τον μετρητή του προγράμματος
					
		# Αν ο χρήστης δώσει αρνητικούς αριθμούς, τους μετατρέπουμε σε θετικούς με την κλήση κατάλληλης συνάρτησης
		bltz $t0,if_t0_negative # Aν $t0 < 0 κάνε άλμα στο if_t0_negative
		bltz $t1,if_t1_negative # Aν $t1 < 0 κάνε άλμα στο if_t0_negative
		
		# ΈΛενχος αν ο ένας ή και οι δύο αριθμοί που έδωσε ο χρήστης είναι ίσοι με το μηδέν
		jal check_if_zero       # Άλμα στην συνάρτηση check_if_zero
		
		# Έκτέλεση αλγορίθμου του Ευκλείδη
		jal euclid_loop         # Άλμα στην συνάρτηση euclid_loop
		
		# Τύπωση αποτελεσμάτων
		jal print_result        # Άλμα στην συνάρτηση print_result	
		
	# Εισαγωγή αριθμών από τον χρήστη
	give_numbers:	
		# Τυπώνουμε μήνυμα στον χρήστη για να εισάγει τον 1ο αριθμό
		la $a0,msg1  # Αποθήκευση διεύθυνσης msg0 στον καταχωρητή $a0
		li $v0,4     # Κλήση για εκτέλεση εκτύπωσης string	
		syscall      # Εκτέλεση
		
		# Ο χρήστης εισάγει τον πρώτο αριθμό
		li $v0,5     # Κλήση για διάβασμα ακεραίου  
		syscall      # Εκτέλεση
		move $t0,$v0 # Αποθήκευση της τιμής στον καταχωρητή $t0
		
		# Στη συνέχεια ζητάμε απο τον χρήστη να εισάγει και τον 2ο αριθμό
		la $a0,msg2  # Αποθήκευση διεύθυνσης msg0 στον καταχωρητή $a0
		li $v0,4     # Κλήση για εκτέλεση εκτύπωσης string
		syscall      # Εκτέλεση

		# Ο χρήστης εισάγει και τον δεύτερο αριθμό		
		li $v0,5     # Κλήση για διάβασμα ακεραίου 
		syscall      # Εκτέλεση
		move $t1,$v0 # Αποθήκευση της τιμής στον καταχωρητή $t1
		
		# Επιστροφή στον βρόνχο
		jr $ra 	     # Έξοδος από την συνάρτηση και επιστροφή στον καταχωρητή $ra	
		
	# Μετατροπή της τιμής του καταχωρητή $t0 σε θετική
	if_t0_negative:						
		sub $t0, $0, $t0 # Αφαιρούμε την τιμή του καταχωρητή $t0 από το μηδέν για να την μετατρέψουμε σε θετική
		jr $ra           # Έξοδος από την συνάρτηση και επιστροφή στον καταχωρητή $ra
	
	# Μετατροπή της τιμής του καταχωρητή $t1 σε θετική			
	if_t1_negative:		
		sub $t1, $0, $t1 # Αφαιρούμε την τιμή του καταχωρητή $t1 από το μηδέν για να την μετατρέψουμε σε θετική
		jr $ra           # Έξοδος από την συνάρτηση και επιστροφή στον καταχωρητή $ra

	# Συνάρτηση για τις περιπτώσεις όπου ο ένας ή και οι δύο αριθμοί είναι μηδέν
	check_if_zero: 	
		# Αν η τιμή του καταχωρητή $t0 δεν είναι μηδέν καλούμε την αντίστοιχη συνάρτηση. Ομοίως και για τον καταχωρητή $t1
		bnez $t0, if_t0_not_zero # if $t0 != 0 goto if_t0_not_zero			
		bnez $t1, if_t1_not_zero # if $t1 != 0 goto if_t1_not_zero
		
		# Αν και οι 2 αριθμοί είναι ίσοι με το μηδέν τυπώνουμε το αντίστοιχο μήνυμα
		la $a0,msg4              # Αποθήκευση διεύθυνσης msg4 στον καταχωρητή $a0 
		li $v0,4                 # Αποθήκευση διεύθυνσης msg1 στον καταχωρητή $a0 
		syscall                  # Εκτέλεση
			
		j loop                   # Άλμα στην συνάρτηση loop
		
	# Σε περίπτωση όπου η τιμή του $t0 δεν είναι μηδέν, ελένχουμε αν η τιμή του $t1 είναι. Αν ναι τότε το $t0 είναι το αποτέλεσμα	
	if_t0_not_zero:
		bnez $t1, return # if $t1 != 0 goto return
		j print_result   # H συνάρτηση print_result τυπώνει τον καταχωρητή $t0 οπότε απλά κάνουμε άλμα σε αυτήν

	# Σε περίπτωση όπου η τιμή του $t1 δεν είναι μηδέν, ελένχουμε αν η τιμή του $t0 είναι. Αν ναι τότε το $t1 είναι το αποτέλεσμα			
	if_t1_not_zero:
		move $t0,$t1   # Αποθήκευση της τιμής του καταχωρητή $t1 στον καταχωρητή $t0 
		j print_result # Άλμα στην συνάρτηση print_result
	
	# Συνάρτηση με την εντολή jr $ra για να καλείται από τις συνθήκες 			
	return: 
		jr $ra # Έξοδος από την συνάρτηση και επιστροφή στον καταχωρητή $ra	
		
	# Εκτέλεση του αλγόριθμου του Ευκλείδη
	euclid_loop:		
		div $t0, $t1           # Ακέραια διαίρεση των τιμών των καταχωρητών $t0, $t1 και αποθήκευση του πηλίκου της διαίρεσης στον καταχωρητή Lo και του υπολοίπου στον καταχωρητή Hi		move $t0,$t1 # Αποθήκευση της τιμής του καταχωρητή $t1 στον καταχωρητή $t0
		mfhi $t1               # Μεταφορά αποτελέσματος από τον καταχωρητή Hi στον καταχωρητή $t1
			
		# Eπανάληψη βρόνχου μέχρι η διαίρεση να δώσει υπόλοιπο μηδέν
		bne $t1,0,euclid_loop  # Αν $t1 != 0 κάνε άλμα στο euclid_loop 		
			
		jr $ra                 # Έξοδος από την συνάρτηση και επιστροφή στον καταχωρητή $ra
		
	# Τύπωση αποτελέσματος
	print_result:
		la $a0,msg3   # Αποθήκευση διεύθυνσης msg3 στον καταχωρητή $a0 
		li $v0,4      # Κλήση για εκτέλεση εκτύπωσης string
		syscall       # Εκτέλεση		
		
		move $a0,$t0  # Αποθήκευση της τιμής του καταχωρητή $t0 στον καταχωρητή $a0 
		li $v0,1      # Κλήση για εκτέλεση εκτύπωσης ακεραίου
		syscall       # Εκτέλεση
		
		la $a0, enter # Αποθήκευση διεύθυνσης enter στον καταχωρητή $a0 
		li $v0,4      # Κλήση για εκτέλεση εκτύπωσης string
		syscall       # Εκτέλεση 
		
		j loop        # Άλμα στην συνάρτηση loop
	
	# Τερματισμός προγράμματος
	exit:
		li $v0,10 # Κλήση για έξοδο
		syscall   # Εκτέλεση
